<html>

<head>
<title>WebGL Fluid</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">


<script type="text/javascript" src="glMatrix-0.9.5.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="o3djs/base.js"></script>
<script type="text/javascript" src ="tracer.js"></script>
<script type="text/javascript" src ="primitives.js"></script>
<script type="text/javascript" src ="loadObj.js"></script>
<script type="text/javascript" src="threejs/three.js"></script>
<script type="text/javascript" src="threejs/OBJLoader.js"></script>
<script type="text/javascript" src="dat.gui.min.js"></script>
<script type="text/javascript" src="main.js"></script>



<script id="pool-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNmlMatrix;
    uniform mat4 uLightMatrix;
    uniform mat4 uLightProj;
    varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    varying vec3 vVertexNormal;
    varying vec3 vDepthPosition;
    const mat4 ScaleMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);
    void main(void) {
       vVertexPosition = aVertexPosition;
       vVertexPosition.y -= 0.3;
        gl_Position = uPMatrix * uMVMatrix * vec4(vVertexPosition, 1.0);
       // vVertexPosition = (uMVMatrix*vec4(aVertexPosition,1.0)).xyz;
       
        vTextureCoord = aTextureCoord;
        vVertexNormal = aVertexNormal;
      // vVertexNormal = (uNmlMatrix * vec4(aVertexNormal,0.0)).xyz;  
       vDepthPosition = (ScaleMatrix * uLightProj * uLightMatrix * vec4(vVertexPosition, 1.0)).xyz;
    }
</script>

<script id="pool-fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    varying vec3 vVertexNormal;
    varying vec3 vDepthPosition;
    uniform sampler2D uSamplerTile;
    uniform sampler2D uSamplerCaustic;
    uniform sampler2D uSamplerWater; 
    uniform sampler2D uSamplerDepth;
    uniform sampler2D uSamplerGodray;
  
   uniform vec3 uSphereCenter;
   uniform float uSphereRadius;
   uniform float uCausticOn;
   uniform int uIsSphere;
    float waterHeight = 0.0;
    vec3 lightPos = vec3(0.0,2.0,-2.0);
    vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
   // vec3 lightDir = vec3(0.5,1.2,0.3);
    vec3 underwaterColor = vec3(0.4, 0.9, 1.0);
    float lightIntensity = 1.4;
    float poolHeight = 0.65;
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;
    
    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
        vec3 tMin = (cubeMin - origin) / ray;
        vec3 tMax = (cubeMax - origin) / ray;
        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);
        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);
        return vec2(tNear, tFar);
    }
    vec3 getWallColor(vec3 point) {
        float scale = 0.5;
        vec3 wallColor = vec3(1.0, 0.0, 0.0);
        vec3 normal;
        if (abs(point.x) > 0.999) {  //left,right wall
          wallColor = texture2D(uSamplerTile, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;
          normal = vec3(-point.x, 0.0, 0.0);
        }
        else if (abs(point.z) > 0.999) {   //front,back wall
          wallColor = texture2D(uSamplerTile, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;
          normal = vec3(0.0, 0.0, -point.z);
        } 
        else {   //bottm wall
          wallColor = texture2D(uSamplerTile, point.xz * 0.5 + 0.5).rgb;
          normal = vec3(0.0, 1.0, 0.0);
        }
        
        scale /= length(point); 
        scale *= 1.0 - 0.9 / pow(length(point - uSphereCenter) / uSphereRadius, 4.0); 
        vec3 refractedLight = -refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
        float diffuse = max(0.0, dot(refractedLight, normal));
        vec4 data = texture2D(uSamplerWater, point.xz * 0.5 + 0.5);
        if (point.y < data.r ) {
           vec4 caustic = texture2D(uSamplerCaustic, 0.65 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
           if(uCausticOn > 0.0)
                scale += diffuse * caustic.r * 2.0 * caustic.g;
        } else {
          vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
          diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 1.0 / 2.0)));
          scale += diffuse * 0.7;
        }
        
        return wallColor * scale ;
  }
  float linearizeDepth( float exp_depth, float near, float far ){
      return ( 2.0 * near ) / ( far + near - exp_depth * ( far - near ) );
  }
  float getObjShadow(vec3 position, vec3 normal){
        float texelSize = 1.0 / 512.0;
        vec3 c = vec3(0.0);
        float depth = 0.0;
        vec2 coord = position.xy;
        if(normal.z > 0.999){   //front wall
            coord.y = 1.0- coord.y;
        }else if(normal.x > 0.999){  //right wall
            coord.y = 1.0- coord.y;
        }
        
        int count = 0;
        for (int y = -1; y <= 1; ++y){
          for (int x = -1; x <= 1; ++x){
              vec2 offset = coord + vec2(float(x) * texelSize, float(y) * texelSize);
  
              depth = texture2D(uSamplerDepth, offset).r;
              depth = linearizeDepth(depth, 1.0, 20.0);
      
              if ( position.z > depth ){   //part of shadow
                c += vec3(0.1, 0.1, 0.1);
               //color = vec3(1.0, 0.0, 0.0);
              }
              ++count;
            }
        }
        // if ( count > 0 )
        //   c *= float(count) *0.1;
        float shadow = (1.0 - length(c));
        shadow = clamp(1.0 / (1.0 + exp(-shadow)), 0.0, 1.0);
        return shadow *1.4;
  }
    void main(void) {
        vec3 lightDir = normalize(vVertexPosition-lightPos);
        //float diffuseTerm = clamp(dot(normalize(lightDir), normalize(vVertexNormal) ), 0.0, 1.0);
        vec3 color = getWallColor(vVertexPosition);
        vec4 data = texture2D(uSamplerWater, vVertexPosition.xz * 0.5 + 0.5);
        waterHeight = data.r;
        if(vVertexPosition.y < waterHeight){
            color *= underwaterColor;
        }
        //vec2 tCube = intersectCube(lightPos, lightDir, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
        //vec3 hitCube = lightPos - lightDir * tCube.y;
        //if(hitCube.y<0.99)
            //scolor *= vec3(0.5,0.5,0.5);
            
      // float dep = texture2D(uSamplerDepth, vVertexPosition.xz * 0.5 + 0.5).r;
      // dep = linearizeDepth( dep, 1.0, 10.0);
      //  color += vec3(1.0-dep,1.0-dep,1.0-dep);
      if(uIsSphere == 0){
        color *= getObjShadow(vDepthPosition, vVertexNormal);
      }
        // if(vVertexNormal.y<-0.999 && uIsSphere == 0){
        //   vec3 position = vDepthPosition;
        //   float texelSize = 1.0 / 512.0;
        //   vec3 c = vec3(0.0);
        //   float depth = 0.0;
        //   int count = 0;
        //   for (int y = -1; y <= 1; ++y){
        //     for (int x = -1; x <= 1; ++x){
        //       vec2 offset = position.xy + vec2(float(x) * texelSize, float(y) * texelSize);
    
        //         depth = texture2D(uSamplerDepth, offset).r;
        //         depth = linearizeDepth(depth, 1.0, 20.0);
        
        //         if ( position.z > depth ){   //part of shadow
        //           c += vec3(0.1, 0.1, 0.1);
        //          //color = vec3(1.0, 0.0, 0.0);
        //         }
        //         ++count;
        //       }
        //   }
        //   // if ( count > 0 )
        //   //   c *= float(count) *0.1;
        //   float shadow = (1.0 - length(c));
        //   shadow = clamp(1.0 / (1.0 + exp(-shadow)), 0.0, 1.0);
        //   color *= shadow *1.4;
          
        // }
        //color += 0.25* vec3(texture2D(uSamplerGodray, vVertexPosition.xz * 0.5 + 0.5).r);
       gl_FragColor = vec4(color, 1.0);
    }
</script>

<script id="godray-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTexcoord;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uLightMatrix;    
    varying vec3 vDepthPosition;
    varying vec2 v_texcoord;
    varying vec2 delta;// delta from current pixel to "sun" position
    vec3 lightPos = vec3(5000.0,12020.0,2980.0);
    const mat4 ScaleMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);
    
    void main(void) {
      gl_Position = vec4(aVertexPosition, 1.0);
      v_texcoord = aTexcoord;//aTexcoord;//vec2(1.0 - v_texcoord.x, v_texcoord.y);
      vec2 screenLightPos = vec4(ScaleMatrix *uPMatrix * uMVMatrix * vec4(lightPos, 1.0)).xy;
      delta = (screenLightPos - aVertexPosition.xy);
      //vDepthPosition = (ScaleMatrix * uPMatrix * uMVMatrix* vec4(aVertexPosition, 1.0)).xy;;
    }
        
</script>
<script id="godray-fs" type="x-shader/x-fragment">
    precision highp float;
    #define TAPS_PER_PASS 6.0
    uniform sampler2D uSamplerInput;
    uniform float uPass;
    varying vec3 vDepthPosition;
    varying vec2 v_texcoord;
    varying vec2 delta;
    float linearizeDepth( float exp_depth, float near, float far ){
  return ( 2.0 * near ) / ( far + near - exp_depth * ( far - near ) );
}
    void main(void){
        float filterLen = 1.0;
        float stepSize = filterLen * pow(TAPS_PER_PASS, -uPass);
        
        float dist = length( delta );
        // Step vector (uv space)
        vec2 stepv = stepSize * delta / dist;
        // Number of iterations between pixel and sun
        float iters = dist/stepSize;
        float col = 0.0;
        vec2 uv = v_texcoord;
        //if ( 0.0 <= iters && uv.y < 1.0 ) 
        col += linearizeDepth(texture2D( uSamplerInput, uv ).r, 1.0, 10.0);
		uv += stepv;
        float damp = 1.0;
		//if ( 1.0 <= iters && uv.y < 1.0 ) 
        col += damp*linearizeDepth(texture2D( uSamplerInput, uv ).r, 1.0, 10.0);
		uv += stepv;
        damp -= 0.1;
		//if ( 2.0 <= iters && uv.y < 1.0 ) 
        col += damp*linearizeDepth(texture2D( uSamplerInput, uv ).r, 1.0, 10.0);
		uv += stepv;

		//if ( 3.0 <= iters && uv.y < 1.0 ) 
        col += damp*linearizeDepth(texture2D( uSamplerInput, uv ).r, 1.0, 10.0);
		uv += stepv;

		//if ( 4.0 <= iters && uv.y < 1.0 ) 
        col += damp*linearizeDepth(texture2D( uSamplerInput, uv ).r, 1.0, 10.0);
		uv += stepv;

		//if ( 5.0 <= iters && uv.y < 1.0 ) 
        col += damp*linearizeDepth(texture2D( uSamplerInput, uv ).r, 1.0, 10.0);
		uv += stepv;
        //float depth = linearizeDepth( texture2D( uSamplerInput, uv ).r, 0.5, 5.0 );
        gl_FragColor = vec4( col/TAPS_PER_PASS );
        gl_FragColor.a = 1.0;
        
    }
</script>   

<script id="sky-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
   // attribute vec2 aTextureCoord;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
   // varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
       // vTextureCoord = aTextureCoord;
        vVertexPosition = aVertexPosition;
    }
</script>

<script id="sky-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform samplerCube uSamplerSky;
    //varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    void main(void) {
         gl_FragColor = textureCube(uSamplerSky, vVertexPosition);
        //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    }
</script>

<script id="obj-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
   // attribute vec2 aTextureCoord;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec3 uCenter;
   // uniform vec3 uRadius;
   // varying vec2 vTextureCoord;
    varying vec3 vVertexPosition;
    varying vec3 vVertexNormal;
    void main(void) {
        vVertexPosition = uCenter + aVertexPosition;
        // vVertexPosition = aVertexPosition;
        gl_Position = uPMatrix * uMVMatrix * vec4(vVertexPosition, 1.0);
       // vTextureCoord = aTextureCoord;
       
        vVertexNormal = aVertexNormal;
    }
</script>

<script id="obj-fs" type="x-shader/x-fragment">
    precision highp float;
    //uniform sampler2D uSamplerSphere;
    //varying vec2 vTextureCoord;
   // uniform vec3 uDiffuseColor;
   uniform float uSphereRadius;
    uniform vec3 uSphereCenter;
    uniform int uIsSphere;
    uniform sampler2D uSamplerWater; 
    uniform sampler2D uSamplerCaustic;
    uniform float uCausticOn;
    varying vec3 vVertexPosition;
    varying vec3 vVertexNormal;
    vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;
    vec3 underwaterColor = vec3(0.4, 0.9, 1.0);
    
    vec3 getSphereColor(vec3 point,  vec3 sphereCenter, float sphereRadius) {
      vec3 color = vec3(0.5);
      color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.x)) / sphereRadius, 3.0);
      color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.z)) / sphereRadius, 3.0);
      color *= 1.0 - 0.9 / pow((point.y + 1.0 + sphereRadius) / sphereRadius, 3.0);
      vec3 sphereNormal = (point - sphereCenter) / sphereRadius;
      vec3 refractedLight = refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      float diffuse = max(0.0, dot(-refractedLight, sphereNormal)) * 0.5;
      vec4 data = texture2D(uSamplerWater, point.xz * 0.5 + 0.5);
      if (point.y < data.r) {
        vec4 caustic = texture2D(uSamplerCaustic, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
        if(uCausticOn > 0.0)
        diffuse *= caustic.r * 4.0;
      }
      color += diffuse;
      return color;
  }
    void main(void) {
        vec3 color;
        vec4 data = texture2D(uSamplerWater, vVertexPosition.xz * 0.5 + 0.5);
        if(uIsSphere == 1){
          color = getSphereColor(vVertexPosition, uSphereCenter, uSphereRadius);
       }
       else{
          color = vec3(1.0, 1.0, 0.0);
          color *= clamp(dot(lightDir, vVertexNormal), 0.20,1.0);
          if(vVertexPosition.y < data.r){
            vec3 refractedLight = refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
            vec4 caustic = texture2D(uSamplerCaustic, 0.75 * (vVertexPosition.xz - vVertexPosition.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
            if(caustic.r> 0.2){
              if(uCausticOn > 0.0)
                color *= caustic.r * 4.0;
            }
          }
       }
      if(vVertexPosition.y < data.r){
          color *= underwaterColor;
        }
        gl_FragColor = vec4(color,1.0);
    }
</script>

<script id="water-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    //attribute vec2 aTextureCoord;
    attribute vec3 aVertexNormal;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNmlMatrix;  //for normal transformations
    uniform mat4 uReflectpMatrix;
    uniform mat4 uReflectmvMatrix;
    uniform sampler2D uSamplerWater;  //height texture: [position.y, normal.x, normal.z, velocity.y]
    varying vec3 vVertexPosition;
    varying vec3 vReflectPosition;
    const mat4 ScaleMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);
    //varying vec3 vVertexNormal;
    void main(void) {
        vec4 data = texture2D(uSamplerWater, aVertexPosition.xy * 0.5 + 0.5);
       
       // gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);//screen coord
        //vVertexNormal = (uNmlMatrix * vec4(aVertexNormal, 0.0)).xyz;
        vVertexPosition = aVertexPosition.xzy;//gl_Position.xyz;
        vVertexPosition.y += data.x;   //retrieve height
        vVertexPosition.y += data.r;   //retrieve height
        gl_Position = uPMatrix * uMVMatrix * vec4(vVertexPosition, 1.0);
        vReflectPosition = (ScaleMatrix * uReflectpMatrix* uReflectmvMatrix * vec4(vVertexPosition, 1.0)).xyz;
    }
</script>

<script id="water-fs" type="x-shader/x-fragment">
   precision highp float;
    uniform sampler2D uSamplerTile;    //refracted ray shows pool tiles
    uniform samplerCube uSamplerSky;   //top water reflects skybox
    uniform sampler2D uSamplerWater; 
    uniform sampler2D uSamplerCaustic;
    uniform sampler2D uSamplerReflect;   //contains obj render for reflection
    uniform vec3 uEyePosition;
    uniform int uProgNum;   //there is two water program, one is plane upper face, other is plane lower face
    uniform int uIsSphere;
    uniform float uSphereRadius;
    uniform vec3 uSphereCenter;
    uniform float uCausticOn;
    varying vec3 vVertexPosition;
     varying vec3 vReflectPosition;
   // varying vec3 vVertexNormal;
    float waterHeight = 0.0;
    vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
    float poolHeight = 0.65;
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;
    float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
      vec3 toSphere = origin - sphereCenter;
      float a = dot(ray, ray);
      float b = 2.0 * dot(toSphere, ray);
      float c = dot(toSphere, toSphere) - sphereRadius * sphereRadius;
      float discriminant = b*b - 4.0*a*c;
      if (discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.0) return t;
      }
      return 1.0e6;
  }
    
    
    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
        vec3 tMin = (cubeMin - origin) / ray;
        vec3 tMax = (cubeMax - origin) / ray;
        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);
        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);
        return vec2(tNear, tFar);
    }
    float intersectTri(vec3 origin, vec3 ray, vec3 a, vec3 b,  vec3 c) {
      vec3 ab = b - a;
      vec3 ac = c - a;
      vec3 normal = normalize(cross(ab, ac));
      vec3 oa = a - origin;
      float t = dot(normal, oa) / dot(normal, ray);
      if (t > 0.0) {
        vec3 hit = origin + ray*t;
        vec3 toHit = hit - a;
        float dot00 = dot(ac,ac);
        float dot01 = dot(ac, ab);
        float dot02 = dot(ac, toHit);
        float dot11 = dot(ab, ab);
        float dot12 = dot(ab, toHit);
        float divide = dot00 * dot11 - dot01 * dot01;
        float u = (dot11 * dot02 - dot01 * dot12) / divide;
        float v = (dot00 * dot12 - dot01 * dot02) / divide;
        if (u >= 0.0 && v >= 0.0 && u + v <= 1.0){ 
          return t;
        }
      }
      return 1.0e6;
    }
    vec3 getSphereColor(vec3 point,  vec3 sphereCenter, float sphereRadius) {
      vec3 color = vec3(0.5);
      color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.x)) / sphereRadius, 3.0);
      color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.z)) / sphereRadius, 3.0);
      color *= 1.0 - 0.9 / pow((point.y + 1.0 + sphereRadius) / sphereRadius, 3.0);
      vec3 sphereNormal = (point - sphereCenter) / sphereRadius;
      vec3 refractedLight = refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      float diffuse = max(0.0, dot(-refractedLight, sphereNormal)) * 0.5;
      vec4 data = texture2D(uSamplerWater, point.xz * 0.5 + 0.5);
      if (point.y < data.r) {
        vec4 caustic = texture2D(uSamplerCaustic, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
        if(uCausticOn > 0.0)
        diffuse *= caustic.r * 4.0;
      }
      color += diffuse;
      return color;
  }
  vec3 getWallColor(vec3 point) {
        float scale = 0.5;
        vec3 wallColor = vec3(1.0, 0.0, 0.0);
        vec3 normal;
        if (abs(point.x) > 0.999) {  //left,right wall
          wallColor = texture2D(uSamplerTile, point.zy * 0.5 + vec2(1.0, 0.5)).rgb;
          normal = vec3(-point.x, 0.0, 0.0);
        }
        else if (abs(point.z) > 0.999) {   //front,back wall
          wallColor = texture2D(uSamplerTile, point.xy * 0.5 + vec2(1.0, 0.5)).rgb;
          normal = vec3(0.0, 0.0, -point.z);
        } 
        else {   //bottm wall
          wallColor = texture2D(uSamplerTile, point.xz * 0.5 + 0.5).rgb;
          normal = vec3(0.0, 1.0, 0.0);
        }
        
        scale /= length(point); 
        scale *= 1.0 - 0.9 / pow(length(point - uSphereCenter) / uSphereRadius, 4.0); 
        vec3 refractedLight = -refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
        float diffuse = max(0.0, dot(refractedLight, normal));
        vec4 data = texture2D(uSamplerWater, point.xz * 0.5 + 0.5);
        if (point.y < data.r) {
           vec4 caustic = texture2D(uSamplerCaustic, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
           if(uCausticOn > 0.0)
           scale += diffuse * caustic.r * 2.0 * caustic.g;
        } else {
          vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
          diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 1.0 / 2.0)));
          scale += diffuse * 0.5;
        }
        
        return wallColor * scale;
  }
    vec3 getRayColor(vec3 origin, vec3 ray, vec3 waterColor) {
        vec3 color;
        float q = intersectSphere(origin, ray, uSphereCenter, uSphereRadius);
        if (q < 1.0e6 && uIsSphere == 1) {
            color = getSphereColor(origin + ray * q,  uSphereCenter, uSphereRadius);
        } else if (ray.y < 0.0) {
          vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
          color = getWallColor(origin + ray * t.y);
        } else {
          vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
          vec3 hit = origin + ray * t.y;
          if (hit.y < 1.0 / 2.0) {
            color = getWallColor(hit);
          } else {
            color = textureCube(uSamplerSky, ray).rgb;
            color += vec3(pow(max(0.0, dot(lightDir, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);
          }
        }
        if (ray.y < 0.0) color *= waterColor;
        return color;
      }
    void main(void) {
        //vec3 normal = normalize(vVertexNormal);
        //vec3 normal = vec3(0,1,0);
        vec2 coord = vVertexPosition.xz * 0.5 + 0.5;
        vec4 data = texture2D(uSamplerWater, coord);
        vec3 normal = vec3(data.g, sqrt(1.0 - dot(data.gb, data.gb)), data.b);
        vec3 eyeDir = normalize(vVertexPosition - uEyePosition);
        
        vec3 underwaterColor = vec3(0.4, 0.9, 1.0);
        vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);
        if(uProgNum == 0){   //above water
         vec3 reflectDir = reflect(eyeDir,normal);
          vec3 refractDir = refract(eyeDir,normal, IOR_AIR / IOR_WATER); 
          float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -eyeDir), 3.0)); 
          vec3 refraColor = getRayColor(vVertexPosition, refractDir, underwaterColor);
          vec3 refleColor = getRayColor(vVertexPosition, reflectDir, underwaterColor);
          vec3 ref = texture2D(uSamplerReflect, vReflectPosition.xy).rgb;
          if(length(ref)>0.0){
              refleColor += ref;
          }
          gl_FragColor = vec4(mix(refleColor, refraColor, fresnel), 1.0);
        }else if(uProgNum == 1){  //below water
          normal = -normal;
          vec3 reflectDir = reflect(eyeDir,normal);
          vec3 refractDir = refract(eyeDir,normal, IOR_WATER/IOR_AIR ); 
          float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -eyeDir), 3.0)); 
          vec3 refraColor = getRayColor(vVertexPosition, refractDir, abovewaterColor);
          vec3 refleColor = getRayColor(vVertexPosition, reflectDir, abovewaterColor);
          gl_FragColor = vec4(mix(refleColor, refraColor, (1.0 - fresnel) * length(refractDir)), 1.0); 
         
        }
        
    }
</script>

<script id="caustic-vs" type="x-shader/x-vertex">
      
     attribute vec3 aVertexPosition;
     uniform sampler2D uSamplerWater;
     varying vec3 oldPos;
     varying vec3 newPos;
     varying vec3 refractedLight;
     float poolHeight = 0.65;
     vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
     const float IOR_AIR = 1.0;
     const float IOR_WATER = 1.333;
     
     vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
        vec3 tMin = (cubeMin - origin) / ray;
        vec3 tMax = (cubeMax - origin) / ray;
        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);
        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);
        return vec2(tNear, tFar);
    }
     vec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {
        vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
        origin += ray * tcube.y;   //tcube  = [tNear, tFar]
        float tplane = ( - poolHeight -origin.y) / refractedLight.y;
        origin += refractedLight * tplane;
        return origin;
     }
  
     void main() {
       vec4 data = texture2D(uSamplerWater, aVertexPosition.xy * 0.5 + 0.5);
       data.gb *= 0.5;  //normal.x, normal.z
       vec3 normal = vec3(data.g, sqrt(1.0 - dot(data.gb, data.gb)), data.b);
       //vec3 normal = vec3(data.g, sqrt(1.0 - data.g*data.g - data.b*data.b), data.b);
       
       refractedLight = refract(-lightDir, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
       vec3 refractedRay = refract(-lightDir, normal, IOR_AIR / IOR_WATER);
       oldPos = project(aVertexPosition.xzy, refractedLight, refractedLight);
       newPos = project(aVertexPosition.xzy + vec3(0.0, data.r, 0.0), refractedRay, refractedLight);
      
       gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);
       //gl_Position = vec4(4.0*newPos.xz, 0.0, 1.0);
      
     }
   
</script>

<script id="caustic-fs" type="x-shader/x-fragment">
    precision highp float;
    uniform float uSphereRadius;
    uniform vec3 uSphereCenter;
    uniform int uIsSphere;
    uniform int OES_standard_derivatives;
    #extension GL_OES_standard_derivatives : enable
     varying vec3 oldPos;
     varying vec3 newPos;
     varying vec3 refractedLight;
     vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
     const float IOR_AIR = 1.0;
     const float IOR_WATER = 1.333;
     float poolHeight = 0.65;
    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
        vec3 tMin = (cubeMin - origin) / ray;
        vec3 tMax = (cubeMax - origin) / ray;
        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);
        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);
        return vec2(tNear, tFar);
    }
     void main() {
       
      // if(OES_standard_derivatives > 0){
          float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));
          float newArea = length(dFdx(newPos)) * length(dFdy(newPos)); 
          gl_FragColor = vec4( oldArea/newArea * 0.2, 1.0, 0.0, 0.0);
     //  }else{
       //   gl_FragColor = vec4(0.2, 0.2, 0.0, 0.0);
      // }
         
      if(uIsSphere == 1){
        //sphere shadow
         vec3 dir = (uSphereCenter - newPos) / uSphereRadius;
         vec3 area = cross(dir, refractedLight);
         float shadow = dot(area, area);
         float dist = dot(dir, -refractedLight);
         shadow = 1.0 + (shadow - 1.0) / (0.05 + dist * 0.025);
         shadow = clamp(1.0 / (1.0 + exp(-shadow)), 0.0, 1.0);
        // shadow = mix(1.0, shadow, clamp(dist * 2.0, 0.0, 1.0));
         gl_FragColor.g = shadow;
      }
      //caustics
       vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, poolHeight, 1.0));
       float expTerm = -200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 1.0 / 2.0);
       //expTerm = -2.0;
       gl_FragColor.r *= 1.0 / (1.0 + exp(expTerm));
    
     }
    
</script>


<script id="interact-vs" type="x-shader/x-vertex">
 attribute vec3 aVertexPosition;  // [-1, 1]
//  uniform mat4 uMVMatrix;
 // uniform mat4 uPMatrix;
 varying vec2 vCoord;
    void main() {
        gl_Position = vec4(aVertexPosition.xyz, 1.0);
        vCoord = aVertexPosition.xy * 0.5 + 0.5;   //screen coords to texture coords
     }
</script>

<script id="interact-height-fs" type="x-shader/x-fragment">
  precision highp float;
    const float PI = 3.141592653589793;
    uniform sampler2D uSamplerWater;
    uniform vec2 uCenter;    //[-1,1]
    uniform float uRadius;
    uniform float uStrength;
 
   // float radius = 0.03;   //0.03
   // float strength = 0.01;   //0.01
    varying vec2 vCoord;
    float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
    void main() {
      vec4 data = texture2D(uSamplerWater, vCoord);
      vec2 dragCoord = uCenter * 0.5 + 0.5;     //[0,1]
     float dist = length(dragCoord - vCoord);    //[0,1]
      float drag = max(0.0, 1.0 - dist/ uRadius);  
     drag = 0.5 - cos(drag * PI)*0.5;
     data.x += drag* uStrength;

      gl_FragColor = data;
    }
</script>

 <script id="interact-normal-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D uSamplerWater;
    uniform vec2 uDelta;   // [1.0/textureSize, 1.0/textureSize]
    varying vec2 vCoord;
    void main() {   
      vec4 data = texture2D(uSamplerWater, vCoord);
      vec3 dx = vec3(uDelta.x, texture2D(uSamplerWater, vec2(vCoord.x + uDelta.x, vCoord.y)).r - data.r, 0.0);
      vec3 dy = vec3(0.0, texture2D(uSamplerWater, vec2(vCoord.x, vCoord.y + uDelta.y)).r - data.r, uDelta.y);
      data.gb = normalize(cross(dy, dx)).xz;
      gl_FragColor = data;
    }
</script>

<script id="interact-simulate-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D uSamplerWater;
    uniform vec2 uDelta;
    varying vec2 vCoord;
    void main() {
      vec4 data = texture2D(uSamplerWater, vCoord);
      vec2 dx = vec2(uDelta.x, 0.0);
      vec2 dy = vec2(0.0, uDelta.y);
      float average = 0.25 * ( texture2D(uSamplerWater, vCoord - dx).r + texture2D(uSamplerWater, vCoord - dy).r +
        texture2D(uSamplerWater, vCoord + dx).r + texture2D(uSamplerWater, vCoord  + dy).r);
      data.a += (average - data.r) * 2.0;   //get speed
      data.a *= 0.995;   //attenuate speed
      data.r += data.a;   //update height
      gl_FragColor = data;
    }
</script>

<script id="interact-sphere-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D uSamplerWater;
    uniform vec3 uOldCenter;
    uniform vec3 uNewCenter;
    uniform float uRadius;
    varying vec2 vCoord;
    
    float volumeInSphere(vec3 center) {
      vec3 toCenter = vec3(vCoord.x * 2.0 - 1.0, 0.0, vCoord.y * 2.0 - 1.0) - center;
      float t = length(toCenter) / uRadius;
      float dy = exp(-pow(t * 1.5, 6.0));
      float ymin = min(0.0, center.y - dy);
      float ymax = min(max(0.0, center.y + dy), ymin + 2.0 * dy);
      return (ymax - ymin) * 0.05;
    }
    void main() {
      vec4 data = texture2D(uSamplerWater, vCoord);
      data.r += volumeInSphere(uOldCenter);
      data.r -= volumeInSphere(uNewCenter);
      gl_FragColor = data;
    }
</script>

 <script id="depth-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform vec3 uCenter;
    uniform int uMode;
    varying vec3 vVertexNormal;
    varying vec3 vVertexPosition;
    void main (void){

      vec3 position = aVertexPosition + uCenter;
      if(uMode == 0){
        gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
        vVertexNormal = aVertexNormal;
        vVertexPosition = gl_Position.xyz;
      }
      else if(uMode == 1){
       // position.y *= -1.0;
        gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
        vVertexNormal = aVertexNormal;
        //vVertexNormal.y *= -1.0;
        vVertexPosition = gl_Position.xyz;
      }
    }
</script>


<script id="depth-fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec3 vVertexNormal;
    varying vec3 vVertexPosition;
     vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
    void main (void)
    {
      //gl_FragColor = vec4(0.5,0.0,1.0,1.0);
      //if(vVertexPosition.y < 0.0){
        vec3 color = vec3(1.0, 1.0, 0.0);
        color *= clamp(dot(lightDir, vVertexNormal), 0.20,1.0);
        gl_FragColor = vec4(color, 1.0);
      //}
    }
</script>

 <script id="quad-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    varying vec2 vCoord;
    void main (void){
      vCoord = vec2(aTextureCoord.x, aTextureCoord.y);
      gl_Position = vec4( aVertexPosition, 1.0 );
    }
</script>


<script id="quad-fs" type="x-shader/x-fragment">
    precision highp float;
    uniform sampler2D uSamplerDepth;
    uniform int uMode;
    varying vec2 vCoord;
    float linearizeDepth( float exp_depth, float near, float far ){
  return ( 2.0 * near ) / ( far + near - exp_depth * ( far - near ) );
}
    void main (void)
    {

      //float depth = texture2D( uSamplerDepth, vCoord).x;
      //depth = linearizeDepth( depth, 0.5, 5.0 );
      //depth = vCoord.x;
     // gl_FragColor = vec4(texture2D( uSamplerDepth, vCoord).xyz,1.0);
      //gl_FragColor = vec4(vec3(vCoord.x), 1.0)
       //pack(gl_FragCoord.z);

      // if(uMode == 0 ){  //depth
      //      float depth = texture2D( uSamplerDepth, vCoord).x;
      //      depth = linearizeDepth( depth, 0.5, 5.0 );
      //      gl_FragColor = vec4(vec3(depth),1.0);
      // }else if(uMode == 1){   //color
           vec3 color = texture2D( uSamplerDepth, vCoord).rgb;
           gl_FragColor = vec4(color,1.0);
      //}
  

    }
</script>


<script id="perlin-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    uniform float uTime;
    uniform sampler2D uSamplerPerm;
    uniform sampler2D uSamplerGrad;
    varying float vHeight;
    varying vec2 vCoord;
    vec3 fade( vec3 t ) {
          return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );
      }
      float perm( float x ){
          return texture2D( uSamplerPerm, vec2(x/256.0,0.0) ).a * 256.0;
      } 
      float grad( float x, vec3 pp ) {
          return dot( texture2D( uSamplerGrad, vec2( x,0.0) ).rgb, pp );
      }
      float noise( vec3 p )
      {
          vec3 point = mod( floor(p), 256.0 );
          p -= floor(p);
          vec3 fa = fade( p );
          float A = perm( point.x ) + point.y;
          float AA = perm( A ) + point.z;
          float AB = perm( A + 1.0 ) + point.z;
          float B = perm( point.x + 1.0 ) + point.y;
          float BA = perm( B ) + point.z;
          float BB = perm( B+1.0 ) + point.z;
          return mix( 
                      mix(
                          mix( grad(perm(AA), p), grad( perm(BA), p + vec3(-1.0, 0.0, 0.0) ), fa.x),
                          mix(grad(perm(AB), p + vec3(0.0, -1.0, 0.0)), grad(perm(BB), p + vec3(-1.0, -1.0, 0.0)), fa.x), 
                          fa.y
                          ),
                      mix(
                            mix(grad(perm(AA + 1.0), p + vec3(0.0, 0.0, -1.0)), grad(perm(BA + 1.0), p + vec3(-1.0, 0.0, -1.0)), fa.x),
                            mix( grad(perm(AB + 1.0), p + vec3(0.0, -1.0, -1.0)), grad(perm(BB + 1.0), p + vec3(-1.0, -1.0, -1.0)), fa.x),
                            fa.y
                          ),
                      fa.z
                      );
          
    }
    
/*     const  float ONE = 0.00390625;        // 1/ 256
    const  float HALF = 0.001953125;     //0.5/256
    //reference: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
    float fade(float t) {
      // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative
      return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise
    }
    float get_grad(vec2 p, vec3 d){
      return dot(texture2D(uSamplerPerm, p).rgb, d);
    }
    float get_perm(vec2 p){
      return  texture2D(uSamplerPerm, p).a ;
    }
    float pnoise3D(vec3 P){
      vec3 Pi = ONE*floor(P)+HALF;  // Integer part,
      vec3 Pf = fract(P);     // Fractional part 
     // Noise contributions from (x=0, y=0), z=0 and z=1
      float perm00 = get_perm(Pi.xy);//texture2D(uSamplerPerm, Pi.xy).a ;
      float n000 = get_grad(vec2(perm00, Pi.z), Pf);
      float n001 = get_grad(vec2(perm00, Pi.z + ONE), Pf - vec3(0.0, 0.0, 1.0));
      // Noise contributions from (x=0, y=1), z=0 and z=1
      float perm01 = get_perm(Pi.xy + vec2(0.0, ONE));
      float n010 = get_grad(vec2(perm01, Pi.z), Pf - vec3(0.0, 1.0, 0.0));
      float n011 = get_grad(vec2(perm01, Pi.z + ONE), Pf - vec3(0.0, 1.0, 1.0));
      // Noise contributions from (x=1, y=0), z=0 and z=1
      float perm10 = get_perm(Pi.xy + vec2(ONE, 0.0));
      float n100 = get_grad(vec2(perm10, Pi.z), Pf - vec3(1.0, 0.0, 0.0));
      float n101 = get_grad(vec2(perm10, Pi.z + ONE), Pf - vec3(1.0, 0.0, 1.0));
      // Noise contributions from (x=1, y=1), z=0 and z=1
      float perm11 = get_perm(Pi.xy + vec2(ONE, ONE));
      float n110 = get_grad(vec2(perm11, Pi.z), Pf - vec3(1.0, 1.0, 0.0));
      float n111 = get_grad(vec2(perm11, Pi.z + ONE), Pf - vec3(1.0, 1.0, 1.0));
      return mix(
        mix( mix(n000,n100,fade(Pf.x)), mix(n010,n110,fade(Pf.x)), fade(Pf.y) ),
        mix( mix(n001,n101,fade(Pf.x)), mix(n011,n111,fade(Pf.x)), fade(Pf.y) ),
        fade(Pf.z)
        );
    }*/
    void main(void)
    {
       //vertex wave
        // float s_contrib = sin( aVertexPosition.x*2.0*3.14159 + uTime );
        // float t_contrib = cos( aVertexPosition.y*2.0*3.14159 + uTime );
        // vHeight = s_contrib*t_contrib;
        //perlin noise wave
        vHeight = noise( vec3( aVertexPosition.x*2.0 + uTime, aVertexPosition.y*2.0 + uTime, 0.0 ) );
  
        gl_Position = vec4(aVertexPosition.xyz, 1.0);
        vCoord = aVertexPosition.xy * 0.5 + 0.5;
    }
      
</script>

<script id="perlin-fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D uSamplerWater;
    varying float vHeight;
    varying vec2 vCoord;
    void main(void)
    {
        vec4 data = texture2D(uSamplerWater, vCoord);
        data.r += vHeight * 0.0018;
      
        gl_FragColor = data;
    }    
</script>


<script id="rain-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    void main(void) {
      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
        
</script>

<script id="rain-fs" type="x-shader/x-fragment">
    precision highp float;
        
    void main(void) {
         gl_FragColor = vec4(0.4, 0.01, 0.08, 0.6);
    }
</script>

<script id="reflect-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
 //   attribute vec3 aVertexNormal;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    // uniform vec3 uCenter;
    // varying vec3 vVertexNormal;
    void main(void) {
      // vec3 position = aVertexPosition + uCenter;
      // gl_Position = uPMatrix * uMVMatrix * vec4(position, 1.0);
      // vVertexNormal = aVertexNormal;
      gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
        
</script>

<script id="reflect-fs" type="x-shader/x-fragment">
    precision highp float;
    // varying vec3 vVertexNormal;
    vec3 lightDir = normalize(vec3(0.5,1.2,0.3));
    void main(void) {
        // vec3 color = vec3(1.0, 1.0, 0.0);
        // color *= clamp(dot(lightDir, vVertexNormal), 0.20,1.0);
        // gl_FragColor = vec4(color, 1.0);
        gl_FragColor = vec4(1.0, 0.0, 0.0,1.0);
    }
</script>
    
<script id="postprocess-fs" type="x-shader/x-fragment">
    precision highp float;
    uniform sampler2D uSamplerGodray;
    uniform sampler2D uSamplerColor;
    varying vec2 vCoord;
    float linearizeDepth( float exp_depth, float near, float far ){
  return ( 2.0 * near ) / ( far + near - exp_depth * ( far - near ) );
}
    void main (void)
    {
      
      //depth = linearizeDepth( depth, 0.5, 5.0 );
      //depth = vCoord.x;
      vec4 godrayColor = vec4(0.0);
      if((texture2D(uSamplerGodray, vCoord).r) > 0.0) godrayColor = vec4( vec3(-0.15*texture2D(uSamplerGodray, vCoord).r), 0.0);
      gl_FragColor = vec4(texture2D(uSamplerColor, vCoord).xyz, 1.0) - godrayColor;
      //gl_FragColor = vec4(vec3(vCoord.x), 1.0)
       //pack(gl_FragCoord.z);
    }
</script>
    
</head> 

<body onload="webGLStart();">

<table>
      <tr>
          <td>
              <canvas id="the-canvas" width="1080" height="720" style="cursor:hand;">  WebGL unavailable. </canvas>

          </td>

          <td align="left" valign="top" style="position:absolute;left:1080px;padding:20px;">
              <h1><strong>WebGL Interactive Water</strong></h1> <br>
              <a href = "http://www.bingludu.com" target = "_blank"><strong>Binglu's Website</strong></a>  <br>
              <a href = "http://www.maxinjie.com/ " target = "_blank"><strong>Xinjie's Website</strong></a> <br>
              <a href = "https://github.com/dblsai/WebGL-Fluid" target = "_blank"><strong>View Source</strong></a> <br>
              <a href = "https://www.youtube.com/watch?v=Wq27HIlzpmQ&feature=youtu.be" target = "_blank"><strong>Video Demo</strong></a> <br>
              <br><strong>Interaction: </strong><br></h3>
              <ul>
              <li>Right Mouse Button - rotate</li>
              <li>Left Mouse Button - interact </li>
              <li>Middle Mouse Wheel - zoom </li>
   
              </ul>
              <br><strong>Features:</strong> <br>
              <ul>
              <li>Reflection </li>
              <li>Refraction </li>
              <li>Soft Shadow </li>
              <li>Mouse Interaction </li>
              <li>Sphere Interaction </li>
              <li>Caustics </li>
              </ul>
        
      
          <div>fps: <span id="fps"></span></div>
          </td>
      </tr>
</table>

 
</body>

</html>